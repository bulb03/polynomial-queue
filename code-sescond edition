#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct queue{
	int a[80];
	int front;
	int rear;
}z;
int enqueue(int [],int,int,int);
int dequeue(int [],int);
int cal(int,int,int);
int main(void){
	z ini;
	ini.front = 0;
	ini.rear = 0;
	int c,d,parameter,num,i,j;
	num = 0;
	char b[80];
	printf("Please enter the constant:");
	scanf("%d",&c);
	ini.rear = enqueue(ini.a,c,ini.rear,num);
	num++;
	do{
		printf("Please enter the coefficient(if you want to stop,input stop):");
		scanf("%s",b);
		if(strlen(b)==1){    //bug fix!此條件式會解決當輸入stop時，原先b[0]-'0'的問題，此問題進而導致while的判斷式失效 
			printf("%d\n",0); //test用，看條件式有沒有起作用(結果:有，但while仍然不會起作用) 
			d = b[0] - '0';
			ini.rear = enqueue(ini.a,d,ini.rear,num);
			num++;
		}
	//}while(b!="stop");
	}while(strcmp(b,"stop")!=0);        //bug fix! 字串的比較，不能用這麼簡潔的方式(如33行)，要用strcmp之類的 
	printf("Please enter the parameter:");
	scanf("%d",&parameter);
	for(i=ini.front;i<ini.rear;i++){
		if(i==0){
			j = cal(dequeue(ini.a,ini.front),1,i);
			num--;
		}
		else{
			j += cal(dequeue(ini.a,ini.front),parameter,i);
			num--;
		}
	}
	if(num<0){
		printf("The array is empty");
	}
	else{
		printf("f(%d)=%d\n",parameter,j);
	}
	system("pause");
	return 0;
}

int enqueue(int a[],int c,int rear,int num){
	if(num==0){
		rear = 0;
		return rear;
	}
	else{
		a[rear] = c;
		rear++;
		return rear;
	}
}

int dequeue(int a[],int front){
	return a[front];
}

int cal(int x,int p,int i){
	int j=0;
	for(j;j<i;j++){
		x *= x;
	}
	return p*x;
}
